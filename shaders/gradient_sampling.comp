#version 460

// Dispatched at STRATUM resolution: (ceil(width/3), ceil(height/3))
// Each thread processes one stratum and computes the gradient at the sample position.
layout(local_size_x = 16, local_size_y = 16, local_size_z = 1) in;

// Reshaded color (traced in current frame with previous frame's seed)
layout(binding = 0, rgba16f) uniform readonly image2D reshadedColor;

// Forward projected color (previous frame's color projected to current frame)
layout(binding = 1, rgba16f) uniform readonly image2D forwardProjectedColor;

// Current frame Visibility Buffer
layout(binding = 2, rg32ui) uniform readonly uimage2D currentVisibilityBuffer;

// Previous frame Visibility Buffer (projected)
layout(binding = 3, rg32ui) uniform readonly uimage2D prevVisibilityBuffer;

// Motion vector
layout(binding = 4, rg16f) uniform readonly image2D motionVector;

// Output gradient image at STRATUM resolution
layout(binding = 5, rg16f) uniform writeonly image2D gradientOutput;

// Sphere Info Buffer for surface reconstruction
struct SphereInfo {
    vec3 center;
    float radius;
    vec3 color;
    float materialType;
    float materialParam;
    float padding1;
    float padding2;
    float padding3;
};

layout(binding = 7, std430) readonly buffer SphereInfoBuffer {
    SphereInfo spheres[];
};

// Camera UBO for reconstruction
layout(binding = 8) uniform CameraUBO {
    mat4 viewMatrix;
    mat4 projMatrix;
    mat4 viewProjMatrix;
    mat4 invViewProjMatrix;
    mat4 prevViewProjMatrix;

    vec4 cameraPos;
    vec4 cameraFront;
    vec4 cameraUp;
    vec4 cameraRight;
    vec4 frustumInfo;

    vec4 prevCameraPos;
    vec4 prevCameraFront;
    vec4 prevCameraUp;
    vec4 prevCameraRight;

    vec4 resolution;
} camera;

// Push constants - resolution is FULL resolution
layout(push_constant) uniform PushConstants {
    vec4 resolution;      // width, height, 1/width, 1/height
    uint frameNumber;
    float gradientScale;
    float depthThreshold;
    float normalThreshold;
} params;

// Constants
const int STRATUM_SIZE = 3;

// ============================================
// NaN protection functions
// ============================================
bool isNaN(float x) {
    return x != x;
}

bool isNaN(vec3 v) {
    return isNaN(v.x) || isNaN(v.y) || isNaN(v.z);
}

bool isInf(vec3 v) {
    return isinf(v.x) || isinf(v.y) || isinf(v.z);
}

bool isValid(float x) {
    return !isNaN(x) && !isinf(x);
}

bool isValid(vec3 v) {
    return !isNaN(v) && !isInf(v);
}

float sanitize(float x, float fallback) {
    return isValid(x) ? x : fallback;
}

vec3 safeNormalize(vec3 v, vec3 fallback) {
    float len = length(v);
    if (len < 1e-8 || !isValid(len)) {
        return fallback;
    }
    return v / len;
}

// TEA encryption for stable random numbers
uvec2 tea(uvec2 v, uint iterations) {
    uint sum = 0u;
    uint delta = 0x9E3779B9u;

    for (uint i = 0u; i < iterations; i++) {
        sum += delta;
        v.x += ((v.y << 4u) + 0xA341316Cu) ^ (v.y + sum) ^ ((v.y >> 5u) + 0xC8013EA4u);
        v.y += ((v.x << 4u) + 0xAD90777Du) ^ (v.x + sum) ^ ((v.x >> 5u) + 0x7E95761Eu);
    }

    return v;
}

// Get gradient sample position within stratum
ivec2 getGradientSamplePosition(ivec2 stratumCoord, uint frameNumber) {
    uvec2 seed = uvec2(stratumCoord) + uvec2(frameNumber * 1337u, frameNumber * 7331u);
    uvec2 hash = tea(seed, 4u);

    ivec2 offset = ivec2(hash % uvec2(STRATUM_SIZE));

    return stratumCoord * STRATUM_SIZE + offset;
}

// Luminance calculation
float luminance(vec3 color) {
    return dot(color, vec3(0.299, 0.587, 0.114));
}

bool isValidCoord(ivec2 coord, ivec2 size) {
    return coord.x >= 0 && coord.x < size.x && coord.y >= 0 && coord.y < size.y;
}

// ============================================
// Surface reconstruction from Visibility Buffer
// Uses CURRENT camera since we read currentVisibilityBuffer
// ============================================
bool reconstructSurface(ivec2 pixelCoord, ivec2 size,
                        out vec3 worldPos, out vec3 normal, out float hitT, out uint instanceId) {

    uvec4 visData = imageLoad(currentVisibilityBuffer, pixelCoord);
    instanceId = visData.x;
    hitT = uintBitsToFloat(visData.y);

    if (instanceId == 0xFFFFFFFF || hitT < 0.0 || !isValid(hitT)) {
        return false;
    }

    // Reconstruct ray direction from pixel coordinate using CURRENT camera
    vec2 uv = (vec2(pixelCoord) + 0.5) * params.resolution.zw;

    vec3 w = normalize(-camera.cameraFront.xyz);
    vec3 u = normalize(camera.cameraRight.xyz);
    vec3 v = normalize(camera.cameraUp.xyz);
    vec3 origin = camera.cameraPos.xyz;

    float viewport_width = camera.frustumInfo.x;
    float viewport_height = camera.frustumInfo.y;

    vec3 horizontal = viewport_width * u;
    vec3 vertical = viewport_height * v;
    vec3 lower_left_corner = origin - horizontal/2.0 - vertical/2.0 - (camera.frustumInfo.z * w);

    vec3 rayDir = lower_left_corner + uv.x * horizontal + (1.0 - uv.y) * vertical - origin;
    // Do NOT normalize - hitT is parametric along un-normalized ray

    worldPos = origin + rayDir * hitT;

    if (instanceId < 10000u) {
        SphereInfo sphere = spheres[instanceId];
        vec3 toSurface = worldPos - sphere.center;
        normal = normalize(toSurface);
    } else {
        normal = vec3(0.0, 1.0, 0.0);
    }

    return true;
}

void main() {
    // Each thread = one stratum
    ivec2 stratumCoord = ivec2(gl_GlobalInvocationID.xy);
    ivec2 fullSize = ivec2(params.resolution.xy);
    ivec2 stratumSize = (fullSize + ivec2(STRATUM_SIZE - 1)) / STRATUM_SIZE;

    // Bounds check against stratum resolution
    if (stratumCoord.x >= stratumSize.x || stratumCoord.y >= stratumSize.y) {
        return;
    }

    // Get gradient sample position in full-res coordinates
    ivec2 samplePos = getGradientSamplePosition(stratumCoord, params.frameNumber);
    samplePos = clamp(samplePos, ivec2(0), fullSize - ivec2(1));

    // Reconstruct current frame surface at the sample position
    vec3 currentWorldPos, currentNormal;
    float currentHitT;
    uint currentInstanceId;

    bool hasSurface = reconstructSurface(samplePos, fullSize, currentWorldPos, currentNormal, currentHitT, currentInstanceId);

    // ============================================
    // Background handling (Issue 1 fix):
    // If no surface in current frame, check forward projection.
    // If forward-projected data exists, a previous surface projected here
    // but no longer exists -> disocclusion -> maximum gradient.
    // ============================================
    if (!hasSurface) {
        vec4 forwardData = imageLoad(forwardProjectedColor, samplePos);
        vec3 forwarded = forwardData.rgb;
        float forwardedLum = abs(forwarded.r) + abs(forwarded.g) + abs(forwarded.b);

        bool hasForwardData = isValid(forwarded) && forwardedLum > 1e-5 && forwardData.a >= 0.5;

        // If forward projection brought data here but nothing exists now,
        // this is a disocclusion event - output maximum gradient
        vec2 gradientData = hasForwardData ? vec2(1.0, 1.0) : vec2(0.0, 0.0);
        imageStore(gradientOutput, stratumCoord, vec4(gradientData, 0.0, 0.0));
        return;
    }

    // ============================================
    // Hole detection - enhanced color-based
    // ============================================
    vec4 forwardData = imageLoad(forwardProjectedColor, samplePos);
    vec3 forwarded = forwardData.rgb;

    float forwardedLumCheck = abs(forwarded.r) + abs(forwarded.g) + abs(forwarded.b);
    bool isHole = !isValid(forwarded) ||
                  forwardedLumCheck < 1e-5 ||
                  forwardData.a < 0.5;

    // If hole, return maximum gradient (reject history data!)
    if (isHole) {
        imageStore(gradientOutput, stratumCoord, vec4(1.0, 1.0, 0.0, 0.0));
        return;
    }

    // Load reshaded color
    vec4 reshadedData = imageLoad(reshadedColor, samplePos);
    vec3 reshaded = reshadedData.rgb;

    if (!isValid(reshaded)) {
        imageStore(gradientOutput, stratumCoord, vec4(1.0, 1.0, 0.0, 0.0));
        return;
    }

    // ============================================
    // TEMPORAL GRADIENT COMPUTATION
    // ============================================
    float reshadedLum = luminance(reshaded);
    float forwardedLum = luminance(forwarded);

    reshadedLum = sanitize(reshadedLum, 0.0);
    forwardedLum = sanitize(forwardedLum, 0.0);

    float maxLum = max(max(reshadedLum, forwardedLum), 0.001);
    float gradient = abs(reshadedLum - forwardedLum) / maxLum;

    // Small differences are ignored (floating point tolerance)
    gradient = smoothstep(0.02, 0.2, gradient);

    // Apply scale
    gradient = clamp(gradient * params.gradientScale, 0.0, 1.0);
    gradient = sanitize(gradient, 0.0);

    // Weight = 1 for valid gradient samples
    vec2 gradientData = vec2(gradient, 1.0);

    imageStore(gradientOutput, stratumCoord, vec4(gradientData, 0.0, 0.0));
}
