#version 460
#extension GL_EXT_ray_tracing : require

layout(binding = 0, set = 0) uniform accelerationStructureEXT topLevelAS;
layout(binding = 1, set = 0, rgba16f) uniform image2D outputImage;  // HDR output

// Visibility Buffer (replaces G-Buffer WorldPos and Normal)
// Format: RG32_UINT - R = InstanceID, G = HitT (as uint via floatBitsToUint)
layout(binding = 3, set = 0, rg32ui) uniform uimage2D visibilityBuffer;

// Motion Vector (still needed)
layout(binding = 4, set = 0, rg16f) uniform image2D gBufferMotion;

// Camera UBO for motion vectors
layout(binding = 5, set = 0) uniform CameraUBO {
    mat4 viewMatrix;
    mat4 projMatrix;
    mat4 viewProjMatrix;
    mat4 invViewProjMatrix;
    mat4 prevViewProjMatrix;

    vec4 cameraPos;
    vec4 cameraFront;
    vec4 cameraUp;
    vec4 cameraRight;
    vec4 frustumInfo;

    vec4 prevCameraPos;
    vec4 prevCameraFront;
    vec4 prevCameraUp;
    vec4 prevCameraRight;

    vec4 resolution;
} camera;

// Seed output (current frame's seed per pixel)
layout(binding = 6, set = 0, r32ui) uniform uimage2D seedOutput;

// Forward projected seed (from previous frame)
layout(binding = 7, set = 0, r32ui) uniform readonly uimage2D forwardProjectedSeed;

// Reshaded color output (traced with previous frame's seed)
layout(binding = 8, set = 0, rgba16f) uniform image2D reshadedOutput;

layout(push_constant) uniform CameraPushConstants {
    vec3 position;
    vec3 forward;
    vec3 right;
    vec3 up;
    float vfov;
    float defocus_angle;
    float focus_dist;
    uint frameNumber;
} pushCamera;

// Extended ray payload with G-buffer data
struct RayPayload {
    vec3 color;
    vec3 origin;
    vec3 direction;
    uint seed;
    bool hit;
    bool scattered;
    uint instanceId;
    float hitT;

    vec3 worldPosition;
    vec3 worldNormal;
};

layout(location = 0) rayPayloadEXT RayPayload payload;

// Quality settings
const int MAX_DEPTH = 50;
const int SAMPLES_PER_PIXEL = 1;  // A-SVGF requires 1 SPP!

// ===== Random Functions =====
uint hash(uint x) {
    x += (x << 10u);
    x ^= (x >> 6u);
    x += (x << 3u);
    x ^= (x >> 11u);
    x += (x << 15u);
    return x;
}

uint hash(uvec2 v) { return hash(v.x ^ hash(v.y)); }
uint hash(uvec3 v) { return hash(v.x ^ hash(v.y) ^ hash(v.z)); }

float random_double(inout uint seed) {
    seed = hash(seed);
    return float(seed) / 4294967295.0;
}

float random_double_range(inout uint seed, float min, float max) {
    return min + (max - min) * random_double(seed);
}

vec3 random_vec3(inout uint seed, float min, float max) {
    return vec3(
        random_double_range(seed, min, max),
        random_double_range(seed, min, max),
        random_double_range(seed, min, max)
    );
}

vec3 random_in_unit_disk(inout uint seed) {
    for (int i = 0; i < 100; i++) {
        vec3 p = vec3(random_double_range(seed, -1, 1), random_double_range(seed, -1, 1), 0);
        if (dot(p, p) < 1.0)
            return p;
    }
    return vec3(0.0, 0.0, 0.0);
}

vec3 random_unit_vector(inout uint seed) {
    for (int i = 0; i < 100; i++) {
        vec3 p = random_vec3(seed, -1.0, 1.0);
        float lensq = dot(p, p);
        if (1e-160 < lensq && lensq <= 1.0)
            return p / sqrt(lensq);
    }
    return vec3(0.0, 1.0, 0.0);
}

// ===== Camera Variables =====
vec3 cam_center;
vec3 pixel00_loc;
vec3 pixel_delta_u;
vec3 pixel_delta_v;
vec3 cam_u, cam_v, cam_w;
vec3 defocus_disk_u;
vec3 defocus_disk_v;
float cam_defocus_angle;

void initialize_camera() {
    float aspect_ratio = float(gl_LaunchSizeEXT.x) / float(gl_LaunchSizeEXT.y);
    
    cam_center = pushCamera.position;
    cam_defocus_angle = pushCamera.defocus_angle;
    float focus_dist = pushCamera.focus_dist;
    float vfov = pushCamera.vfov;
    
    cam_w = -normalize(pushCamera.forward);
    cam_u = normalize(pushCamera.right);
    cam_v = normalize(pushCamera.up);
    
    int image_width = int(gl_LaunchSizeEXT.x);
    int image_height = int(gl_LaunchSizeEXT.y);
    
    float theta = radians(vfov);
    float h = tan(theta / 2.0);
    float viewport_height = 2.0 * h * focus_dist;
    float viewport_width = viewport_height * aspect_ratio;
    
    vec3 viewport_u = viewport_width * cam_u;
    vec3 viewport_v = viewport_height * -cam_v;
    
    pixel_delta_u = viewport_u / float(image_width);
    pixel_delta_v = viewport_v / float(image_height);
    
    vec3 viewport_upper_left = cam_center - (focus_dist * cam_w) - viewport_u / 2.0 - viewport_v / 2.0;
    pixel00_loc = viewport_upper_left + 0.5 * (pixel_delta_u + pixel_delta_v);
    
    float defocus_radius = focus_dist * tan(radians(cam_defocus_angle / 2.0));
    defocus_disk_u = cam_u * defocus_radius;
    defocus_disk_v = cam_v * defocus_radius;
}

vec3 sample_square(inout uint seed) {
    return vec3(random_double(seed) - 0.5, random_double(seed) - 0.5, 0);
}

vec3 defocus_disk_sample(inout uint seed) {
    vec3 p = random_in_unit_disk(seed);
    return cam_center + (p.x * defocus_disk_u) + (p.y * defocus_disk_v);
}

void get_ray(int i, int j, inout uint seed, out vec3 origin, out vec3 direction) {
    // A-SVGF: No jitter - use pixel center for deterministic rays
    vec3 pixel_sample = pixel00_loc
        + (float(i) + 0.5) * pixel_delta_u
        + (float(j) + 0.5) * pixel_delta_v;
    
    if (cam_defocus_angle > 0.0) {
        origin = defocus_disk_sample(seed);
    } else {
        origin = cam_center;
    }
    
    direction = pixel_sample - origin;
}

// Compute motion vector from world position
vec2 computeMotionVector(vec3 worldPos) {
    vec4 prevClip = camera.prevViewProjMatrix * vec4(worldPos, 1.0);
    vec2 prevNDC = prevClip.xy / prevClip.w;
    prevNDC.y = -prevNDC.y;  // Vulkan Y-axis correction
    vec2 prevUV = prevNDC * 0.5 + 0.5;
    
    vec4 currClip = camera.viewProjMatrix * vec4(worldPos, 1.0);
    vec2 currNDC = currClip.xy / currClip.w;
    currNDC.y = -currNDC.y;
    vec2 currUV = currNDC * 0.5 + 0.5;
    
    return currUV - prevUV;
}

// Reconstruct world position from pixel coordinate and hitT
vec3 reconstructWorldPosition(ivec2 pixel, float hitT) {
    vec2 uv = (vec2(pixel) + 0.5) / vec2(gl_LaunchSizeEXT.xy);
    vec2 ndc = uv * 2.0 - 1.0;
    ndc.y = -ndc.y;  // Vulkan Y-axis
    
    // Use camera parameters to reconstruct ray
    // IMPORTANT: Do NOT normalize direction! gl_HitTEXT is parametric along
    // the un-normalized ray: hit = origin + direction * t
    vec3 ray_origin = pushCamera.position;
    vec3 pixel_sample = pixel00_loc
        + (float(pixel.x) + 0.5) * pixel_delta_u
        + (float(pixel.y) + 0.5) * pixel_delta_v;
    vec3 ray_direction = pixel_sample - ray_origin;
    
    return ray_origin + ray_direction * hitT;
}

// ===== Ray Color Function with Visibility Buffer output =====
vec3 ray_color(vec3 ray_origin, vec3 ray_direction, inout uint seed, 
               out uint primaryInstanceId, out float primaryHitT) {
    vec3 current_attenuation = vec3(1.0);
    vec3 current_origin = ray_origin;
    vec3 current_direction = ray_direction;
    
    // Initialize outputs (for miss case)
    primaryInstanceId = 0xFFFFFFFF;
    primaryHitT = -1.0;
    
    bool firstBounce = true;
    
    for (int depth = 0; depth < MAX_DEPTH; depth++) {
        payload.seed = seed;
        payload.hit = false;
        payload.scattered = false;
        payload.worldPosition = vec3(0.0);
        payload.worldNormal = vec3(0.0);
        payload.instanceId = 0xFFFFFFFF;
        payload.hitT = -1.0;
        
        float tMin = 0.001;
        float tMax = 10000.0;
        
        traceRayEXT(
            topLevelAS,
            gl_RayFlagsOpaqueEXT,
            0xFF,
            0,
            0,
            0,
            current_origin,
            tMin,
            current_direction,
            tMax,
            0
        );
        
        seed = payload.seed;
        
        // Store primary hit data for Visibility Buffer
        if (firstBounce) {
            primaryInstanceId = payload.instanceId;
            primaryHitT = payload.hitT;
            firstBounce = false;
        }
        
        if (!payload.hit) {
            return current_attenuation * payload.color;
        }
        
        if (!payload.scattered) {
            return current_attenuation * payload.color;
        }
        
        current_attenuation *= payload.color;
        current_origin = payload.origin;
        current_direction = payload.direction;
        
        if (dot(current_attenuation, current_attenuation) < 1e-4) {
            return vec3(0.0);
        }
    }
    
    return vec3(0.0);
}

// ===== Ray Color (color only, no visibility output) =====
vec3 ray_color_simple(vec3 ray_origin, vec3 ray_direction, inout uint seed) {
    vec3 current_attenuation = vec3(1.0);
    vec3 current_origin = ray_origin;
    vec3 current_direction = ray_direction;
    
    for (int depth = 0; depth < MAX_DEPTH; depth++) {
        payload.seed = seed;
        payload.hit = false;
        payload.scattered = false;
        
        float tMin = 0.001;
        float tMax = 10000.0;
        
        traceRayEXT(
            topLevelAS,
            gl_RayFlagsOpaqueEXT,
            0xFF,
            0,
            0,
            0,
            current_origin,
            tMin,
            current_direction,
            tMax,
            0
        );
        
        seed = payload.seed;
        
        if (!payload.hit) {
            return current_attenuation * payload.color;
        }
        
        if (!payload.scattered) {
            return current_attenuation * payload.color;
        }
        
        current_attenuation *= payload.color;
        current_origin = payload.origin;
        current_direction = payload.direction;
        
        if (dot(current_attenuation, current_attenuation) < 1e-4) {
            return vec3(0.0);
        }
    }
    
    return vec3(0.0);
}

// ===== Main =====
void main() {
    ivec2 pixelCoord = ivec2(gl_LaunchIDEXT.xy);
    
    // Generate current frame's seed
    uint currentSeed = uint(gl_LaunchIDEXT.x * 1973 + gl_LaunchIDEXT.y * 9277 + pushCamera.frameNumber * 26699 + 123456789);
    currentSeed = hash(currentSeed);
    
    uint initialCurrentSeed = currentSeed;
    
    initialize_camera();
    
    // ========== 1. Trace with current seed (main output) ==========
    vec3 pixel_color = vec3(0.0);
    uint primaryInstanceId = 0xFFFFFFFF;
    float primaryHitT = -1.0;
    
    for (int s = 0; s < SAMPLES_PER_PIXEL; s++) {
        uint seed = hash(currentSeed ^ uint(s * 12345));
        
        vec3 ray_origin, ray_direction;
        get_ray(int(gl_LaunchIDEXT.x), int(gl_LaunchIDEXT.y), seed, ray_origin, ray_direction);
        
        uint sampleInstanceId;
        float sampleHitT;
        
        pixel_color += ray_color(ray_origin, ray_direction, seed, sampleInstanceId, sampleHitT);
        
        if (s == 0) {
            primaryInstanceId = sampleInstanceId;
            primaryHitT = sampleHitT;
        }
    }
    
    pixel_color /= float(SAMPLES_PER_PIXEL);
    
    // Store current frame outputs
    imageStore(outputImage, pixelCoord, vec4(pixel_color, 1.0));
    imageStore(seedOutput, pixelCoord, uvec4(initialCurrentSeed, 0, 0, 0));
    
    // ========== Store Visibility Buffer ==========
    // Format: R = InstanceID, G = HitT (bitcast to uint)
    imageStore(visibilityBuffer, pixelCoord, uvec4(primaryInstanceId, floatBitsToUint(primaryHitT), 0, 0));
    
    // Compute motion vector (reconstruct world position for this)
    vec2 motionVector = vec2(0.0);
    if (primaryHitT > 0.0 && primaryInstanceId != 0xFFFFFFFF) {
        vec3 worldPos = reconstructWorldPosition(pixelCoord, primaryHitT);
        motionVector = computeMotionVector(worldPos);
    }
    imageStore(gBufferMotion, pixelCoord, vec4(motionVector, 0.0, 0.0));
    
    // ========== 2. Reshading: Trace with forward-projected seed ==========
    uint forwardSeed = imageLoad(forwardProjectedSeed, pixelCoord).x;
    
    vec3 reshadedColor = vec3(0.0);
    
    if (forwardSeed != 0u && pushCamera.frameNumber > 0) {
        uint reshade_seed = forwardSeed;
        
        vec3 ray_origin, ray_direction;
        get_ray(int(gl_LaunchIDEXT.x), int(gl_LaunchIDEXT.y), reshade_seed, ray_origin, ray_direction);
        
        reshadedColor = ray_color_simple(ray_origin, ray_direction, reshade_seed);
    }
    
    imageStore(reshadedOutput, pixelCoord, vec4(reshadedColor, 1.0));
}
