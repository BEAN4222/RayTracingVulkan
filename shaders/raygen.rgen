#version 460
#extension GL_EXT_ray_tracing : require

layout(binding = 0, set = 0) uniform accelerationStructureEXT topLevelAS;
layout(binding = 1, set = 0, rgba8) writeonly uniform image2D image;

layout(push_constant) uniform CameraPushConstants {
    vec3 position;
    vec3 forward;
    vec3 right;
    vec3 up;
    float vfov;
    float defocus_angle;
    float focus_dist;
    float padding;
} camera;

struct RayPayload {
    vec3 color;
    vec3 origin;
    vec3 direction;
    uint seed;
    bool hit;
    bool scattered;
};

layout(location = 0) rayPayloadEXT RayPayload payload;

// Quality settings
const int MAX_DEPTH = 50;
const int SAMPLES_PER_PIXEL = 4;  // Lower for real-time

// ===== Random Functions =====
uint hash(uint x) {
    x += (x << 10u);
    x ^= (x >> 6u);
    x += (x << 3u);
    x ^= (x >> 11u);
    x += (x << 15u);
    return x;
}

uint hash(uvec2 v) { return hash(v.x ^ hash(v.y)); }
uint hash(uvec3 v) { return hash(v.x ^ hash(v.y) ^ hash(v.z)); }

float random_double(inout uint seed) {
    seed = hash(seed);
    return float(seed) / 4294967295.0;
}

float random_double_range(inout uint seed, float min, float max) {
    return min + (max - min) * random_double(seed);
}

vec3 random_vec3(inout uint seed, float min, float max) {
    return vec3(
        random_double_range(seed, min, max),
        random_double_range(seed, min, max),
        random_double_range(seed, min, max)
    );
}

vec3 random_in_unit_disk(inout uint seed) {
    for (int i = 0; i < 100; i++) {
        vec3 p = vec3(random_double_range(seed, -1, 1), random_double_range(seed, -1, 1), 0);
        if (dot(p, p) < 1.0)
            return p;
    }
    return vec3(0.0, 0.0, 0.0);
}

vec3 random_unit_vector(inout uint seed) {
    for (int i = 0; i < 100; i++) {
        vec3 p = random_vec3(seed, -1.0, 1.0);
        float lensq = dot(p, p);
        if (1e-160 < lensq && lensq <= 1.0)
            return p / sqrt(lensq);
    }
    return vec3(0.0, 1.0, 0.0);
}

// ===== Camera Variables =====
vec3 cam_center;
vec3 pixel00_loc;
vec3 pixel_delta_u;
vec3 pixel_delta_v;
vec3 cam_u, cam_v, cam_w;
vec3 defocus_disk_u;
vec3 defocus_disk_v;
float cam_defocus_angle;

void initialize_camera() {
    float aspect_ratio = float(gl_LaunchSizeEXT.x) / float(gl_LaunchSizeEXT.y);
    
    // Read from UBO
    cam_center = camera.position;
    cam_defocus_angle = camera.defocus_angle;
    float focus_dist = camera.focus_dist;
    float vfov = camera.vfov;
    
    // Camera basis from UBO
    cam_w = -normalize(camera.forward);  // Opposite of forward
    cam_u = normalize(camera.right);
    cam_v = normalize(camera.up);
    
    int image_width = int(gl_LaunchSizeEXT.x);
    int image_height = int(gl_LaunchSizeEXT.y);
    
    // Viewport dimensions
    float theta = radians(vfov);
    float h = tan(theta / 2.0);
    float viewport_height = 2.0 * h * focus_dist;
    float viewport_width = viewport_height * aspect_ratio;
    
    // Viewport vectors
    vec3 viewport_u = viewport_width * cam_u;
    vec3 viewport_v = viewport_height * -cam_v;
    
    // Pixel delta vectors
    pixel_delta_u = viewport_u / float(image_width);
    pixel_delta_v = viewport_v / float(image_height);
    
    // Upper left pixel location
    vec3 viewport_upper_left = cam_center - (focus_dist * cam_w) - viewport_u / 2.0 - viewport_v / 2.0;
    pixel00_loc = viewport_upper_left + 0.5 * (pixel_delta_u + pixel_delta_v);
    
    // Defocus disk basis vectors
    float defocus_radius = focus_dist * tan(radians(cam_defocus_angle / 2.0));
    defocus_disk_u = cam_u * defocus_radius;
    defocus_disk_v = cam_v * defocus_radius;
}

vec3 sample_square(inout uint seed) {
    return vec3(random_double(seed) - 0.5, random_double(seed) - 0.5, 0);
}

vec3 defocus_disk_sample(inout uint seed) {
    vec3 p = random_in_unit_disk(seed);
    return cam_center + (p.x * defocus_disk_u) + (p.y * defocus_disk_v);
}

void get_ray(int i, int j, inout uint seed, out vec3 origin, out vec3 direction) {
    vec3 offset = sample_square(seed);
    vec3 pixel_sample = pixel00_loc
        + ((float(i) + offset.x) * pixel_delta_u)
        + ((float(j) + offset.y) * pixel_delta_v);
    
    if (cam_defocus_angle > 0.0) {
        origin = defocus_disk_sample(seed);
    } else {
        origin = cam_center;
    }
    
    direction = pixel_sample - origin;
}

// ===== Ray Color Function =====
vec3 ray_color(vec3 ray_origin, vec3 ray_direction, inout uint seed) {
    vec3 current_attenuation = vec3(1.0);
    vec3 current_origin = ray_origin;
    vec3 current_direction = ray_direction;
    
    for (int depth = 0; depth < MAX_DEPTH; depth++) {
        payload.seed = seed;
        payload.hit = false;
        payload.scattered = false;
        
        float tMin = 0.001;
        float tMax = 10000.0;
        
        traceRayEXT(
            topLevelAS,
            gl_RayFlagsOpaqueEXT,
            0xFF,
            0,
            0,
            0,
            current_origin,
            tMin,
            current_direction,
            tMax,
            0
        );
        
        seed = payload.seed;
        
        if (!payload.hit) {
            return current_attenuation * payload.color;
        }
        
        if (!payload.scattered) {
            return current_attenuation * payload.color;
        }
        
        current_attenuation *= payload.color;
        current_origin = payload.origin;
        current_direction = payload.direction;
        
        if (dot(current_attenuation, current_attenuation) < 1e-4) {
            return vec3(0.0);
        }
    }
    
    return vec3(0.0);
}

// ===== Main =====
void main() {
    uint frame_seed = uint(gl_LaunchIDEXT.x * 1973 + gl_LaunchIDEXT.y * 9277 + 123456789);
    uint seed = hash(frame_seed);
    
    initialize_camera();
    
    vec3 pixel_color = vec3(0.0);
    
    for (int s = 0; s < SAMPLES_PER_PIXEL; s++) {
        seed = hash(seed ^ uint(s * 12345));
        
        vec3 ray_origin, ray_direction;
        get_ray(int(gl_LaunchIDEXT.x), int(gl_LaunchIDEXT.y), seed, ray_origin, ray_direction);
        
        pixel_color += ray_color(ray_origin, ray_direction, seed);
    }
    
    pixel_color /= float(SAMPLES_PER_PIXEL);
    
    // Gamma correction
    pixel_color = sqrt(pixel_color);
    
    pixel_color = clamp(pixel_color, 0.0, 0.999);
    
    imageStore(image, ivec2(gl_LaunchIDEXT.xy), vec4(pixel_color, 1.0));
}
