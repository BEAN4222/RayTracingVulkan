#version 460

layout(local_size_x = 16, local_size_y = 16, local_size_z = 1) in;

layout(binding = 0, rgba16f) uniform readonly image2D currentColor;
layout(binding = 1, rg32ui) uniform readonly uimage2D currentVisibilityBuffer;
layout(binding = 2, rg32ui) uniform readonly uimage2D prevVisibilityBuffer;
layout(binding = 3, rg16f) uniform readonly image2D motionVector;
layout(binding = 4, rgba16f) uniform readonly image2D historyColorIn;
layout(binding = 5, rg32f) uniform readonly image2D historyMomentsIn;
layout(binding = 6, r16f) uniform readonly image2D historyLengthIn;
layout(binding = 7, rgba16f) uniform writeonly image2D historyColorOut;
layout(binding = 8, rg32f) uniform writeonly image2D historyMomentsOut;
layout(binding = 9, r16f) uniform writeonly image2D historyLengthOut;
layout(binding = 10, rgba16f) uniform writeonly image2D denoisedOutput;
layout(binding = 11, rg16f) uniform readonly image2D gradientInput;

struct SphereInfo {
    vec3 center;
    float radius;
    vec3 color;
    float materialType;
    float materialParam;
    float padding1;
    float padding2;
    float padding3;
};

layout(binding = 12, std430) readonly buffer SphereInfoBuffer {
    SphereInfo spheres[];
};

layout(binding = 13) uniform CameraUBO {
    mat4 viewMatrix;
    mat4 projMatrix;
    mat4 viewProjMatrix;
    mat4 invViewProjMatrix;
    mat4 prevViewProjMatrix;

    vec4 cameraPos;
    vec4 cameraFront;
    vec4 cameraUp;
    vec4 cameraRight;
    vec4 frustumInfo;

    vec4 prevCameraPos;
    vec4 prevCameraFront;
    vec4 prevCameraUp;
    vec4 prevCameraRight;

    vec4 resolution;
} camera;

layout(push_constant) uniform PushConstants {
    vec4 resolution;
    float alpha;
    float momentsAlpha;
    float depthThreshold;
    float normalThreshold;
    uint frameNumber;
    uint useAdaptiveAlpha;
    float antilagScale;
    float padding;
} params;

bool isNaN(float x) { return x != x; }
bool isNaN(vec3 v) { return isNaN(v.x) || isNaN(v.y) || isNaN(v.z); }
bool isInf(vec3 v) { return isinf(v.x) || isinf(v.y) || isinf(v.z); }
bool isValid(float x) { return !isNaN(x) && !isinf(x); }
bool isValid(vec3 v) { return !isNaN(v) && !isInf(v); }
vec3 sanitize(vec3 v, vec3 fallback) { return isValid(v) ? v : fallback; }
float sanitize(float x, float fallback) { return isValid(x) ? x : fallback; }

float luminance(vec3 color) {
    return dot(color, vec3(0.299, 0.587, 0.114));
}

bool isValidCoord(ivec2 coord, ivec2 size) {
    return coord.x >= 0 && coord.x < size.x && coord.y >= 0 && coord.y < size.y;
}

struct SurfaceData {
    vec3 worldPos;
    vec3 normal;
    float hitT;
    uint instanceId;
    bool valid;
};

SurfaceData reconstructSurfaceWithCamera(uvec4 visData, ivec2 pixelCoord, ivec2 size,
    vec3 origin, vec3 front, vec3 right, vec3 up) {
    SurfaceData data;
    data.valid = false;

    data.instanceId = visData.x;
    data.hitT = uintBitsToFloat(visData.y);

    if (data.instanceId == 0xFFFFFFFF || data.hitT < 0.0 || !isValid(data.hitT)) {
        return data;
    }

    vec2 uv = (vec2(pixelCoord) + 0.5) / vec2(size);

    vec3 w = normalize(-front);
    vec3 u = normalize(right);
    vec3 v = normalize(up);

    float viewport_width = camera.frustumInfo.x;
    float viewport_height = camera.frustumInfo.y;
    float focusDist = camera.frustumInfo.z;

    vec3 horizontal = viewport_width * u;
    vec3 vertical = viewport_height * v;
    vec3 lower_left_corner = origin - horizontal / 2.0 - vertical / 2.0 - focusDist * w;

    // IMPORTANT: Do NOT normalize! hitT is parametric along un-normalized ray
    vec3 rayDir = lower_left_corner + uv.x * horizontal + (1.0 - uv.y) * vertical - origin;
    data.worldPos = origin + rayDir * data.hitT;

    if (!isValid(data.worldPos)) return data;

    if (data.instanceId < 10000u) {
        SphereInfo sphere = spheres[data.instanceId];
        vec3 toSurface = data.worldPos - sphere.center;
        float dist = length(toSurface);
        data.normal = (dist > 1e-6) ? toSurface / dist : vec3(0.0, 1.0, 0.0);
    } else {
        data.normal = vec3(0.0, 1.0, 0.0);
    }

    data.valid = true;
    return data;
}

float computeDepthGradient(ivec2 pixelCoord, ivec2 size, float centerDepth) {
    float grad = 0.0;
    for (int d = -1; d <= 1; d += 2) {
        ivec2 px = pixelCoord + ivec2(d, 0);
        ivec2 py = pixelCoord + ivec2(0, d);
        if (isValidCoord(px, size)) {
            float z = uintBitsToFloat(imageLoad(currentVisibilityBuffer, px).y);
            if (isValid(z) && z > 0.0) grad = max(grad, abs(z - centerDepth));
        }
        if (isValidCoord(py, size)) {
            float z = uintBitsToFloat(imageLoad(currentVisibilityBuffer, py).y);
            if (isValid(z) && z > 0.0) grad = max(grad, abs(z - centerDepth));
        }
    }
    return max(grad, 0.01 * centerDepth);
}

// Antilag: MAX over 3x3 neighborhood from filtered gradient
float computeAntilagAlpha(ivec2 pixelCoord, ivec2 size) {
    float maxAlpha = 0.0;
    for (int yy = -1; yy <= 1; yy++) {
        for (int xx = -1; xx <= 1; xx++) {
            ivec2 p = pixelCoord + ivec2(xx, yy);
            if (!isValidCoord(p, size)) continue;
            vec2 g = imageLoad(gradientInput, p).xy;
            float gradient = sanitize(g.x, 0.0);
            float weight = sanitize(g.y, 0.0);
            float a = (weight > 1e-4) ? clamp(abs(gradient) / weight, 0.0, 1.0) : 0.0;
            maxAlpha = max(maxAlpha, a);
        }
    }
    return maxAlpha;
}

void main() {
    ivec2 pixelCoord = ivec2(gl_GlobalInvocationID.xy);
    ivec2 size = ivec2(params.resolution.xy);

    if (pixelCoord.x >= size.x || pixelCoord.y >= size.y) return;

    vec3 color = sanitize(imageLoad(currentColor, pixelCoord).rgb, vec3(0.0));
    vec2 motion = imageLoad(motionVector, pixelCoord).xy;
    if (!isValid(motion.x) || !isValid(motion.y)) motion = vec2(0.0);

    float l = luminance(color);
    vec2 moments_curr = vec2(l, l * l);

    uvec4 currentVisData = imageLoad(currentVisibilityBuffer, pixelCoord);
    SurfaceData currentSurface = reconstructSurfaceWithCamera(currentVisData, pixelCoord, size,
        camera.cameraPos.xyz, camera.cameraFront.xyz,
        camera.cameraRight.xyz, camera.cameraUp.xyz);

    float depthGrad = 0.0;
    if (currentSurface.valid) {
        depthGrad = computeDepthGradient(pixelCoord, size, currentSurface.hitT);
    }

    // Reprojection using motion vector
    vec2 pos_prev = vec2(pixelCoord) + 0.5 - motion * vec2(size);
    ivec2 p = ivec2(floor(pos_prev - 0.5));
    vec2 frac = (pos_prev - 0.5) - floor(pos_prev - 0.5);

    vec3 color_prev = vec3(0.0);
    vec2 moments_prev = vec2(0.0);
    float histlen = 0.0;
    float sum_w = 0.0;

    if (params.frameNumber > 0 && currentSurface.valid) {
        // Per-tap bilinear with validation
        for (int yy = 0; yy <= 1; yy++) {
            for (int xx = 0; xx <= 1; xx++) {
                ivec2 tap = p + ivec2(xx, yy);
                if (!isValidCoord(tap, size)) continue;

                uvec4 prevVisData = imageLoad(prevVisibilityBuffer, tap);
                SurfaceData prevSurface = reconstructSurfaceWithCamera(prevVisData, tap, size,
                    camera.prevCameraPos.xyz, camera.prevCameraFront.xyz,
                    camera.prevCameraRight.xyz, camera.prevCameraUp.xyz);

                if (!prevSurface.valid) continue;
                if (currentSurface.instanceId != prevSurface.instanceId) continue;
                if (dot(currentSurface.normal, prevSurface.normal) < 0.95) continue;

                float z_diff = abs(currentSurface.hitT - prevSurface.hitT);
                if (z_diff > 2.0 * (depthGrad + 1e-3)) continue;

                float w = (xx == 0 ? (1.0 - frac.x) : frac.x)
                        * (yy == 0 ? (1.0 - frac.y) : frac.y);

                vec3 c = imageLoad(historyColorIn, tap).rgb;
                if (!isValid(c)) continue;

                color_prev   += c * w;
                moments_prev += imageLoad(historyMomentsIn, tap).xy * w;
                histlen      += imageLoad(historyLengthIn, tap).x * w;
                sum_w        += w;
            }
        }

        // 3x3 fallback for robustness
        if (sum_w < 0.01) {
            float bestDist = 1e10;
            ivec2 bestTap = ivec2(-1);
            ivec2 center = ivec2(floor(pos_prev));

            for (int yy = -1; yy <= 1; yy++) {
                for (int xx = -1; xx <= 1; xx++) {
                    ivec2 tap = center + ivec2(xx, yy);
                    if (!isValidCoord(tap, size)) continue;

                    uvec4 prevVisData = imageLoad(prevVisibilityBuffer, tap);
                    SurfaceData prevSurface = reconstructSurfaceWithCamera(prevVisData, tap, size,
                        camera.prevCameraPos.xyz, camera.prevCameraFront.xyz,
                        camera.prevCameraRight.xyz, camera.prevCameraUp.xyz);

                    if (!prevSurface.valid) continue;
                    if (currentSurface.instanceId != prevSurface.instanceId) continue;
                    if (dot(currentSurface.normal, prevSurface.normal) < 0.9) continue;

                    float z_diff = abs(currentSurface.hitT - prevSurface.hitT);
                    if (z_diff > 4.0 * (depthGrad + 1e-3)) continue;

                    vec3 c = imageLoad(historyColorIn, tap).rgb;
                    if (!isValid(c)) continue;

                    float dist = length(vec2(tap) - pos_prev);
                    if (dist < bestDist) {
                        bestDist = dist;
                        bestTap = tap;
                    }
                }
            }

            if (bestTap.x >= 0) {
                color_prev   = imageLoad(historyColorIn, bestTap).rgb;
                moments_prev = imageLoad(historyMomentsIn, bestTap).xy;
                histlen      = imageLoad(historyLengthIn, bestTap).x;
                sum_w        = 1.0;
            }
        }
    }

    vec3 outputColor;
    vec2 outputMoments;
    float outputLength;

    if (sum_w > 0.01) {
        if (sum_w < 0.99) {
            color_prev   /= sum_w;
            moments_prev /= sum_w;
            histlen      /= sum_w;
        }

        // === Neighborhood color clamping (variance clipping) ===
        // Standard SVGF/TAA technique: clamp history to current frame's local color range
        // Prevents ghosting at disocclusion boundaries (e.g., sphere edges against sky)
        {
            vec3 m1 = vec3(0.0); // mean
            vec3 m2 = vec3(0.0); // mean of squares
            float cnt = 0.0;
            for (int yy = -1; yy <= 1; yy++) {
                for (int xx = -1; xx <= 1; xx++) {
                    ivec2 np = pixelCoord + ivec2(xx, yy);
                    if (!isValidCoord(np, size)) continue;
                    vec3 nc = imageLoad(currentColor, np).rgb;
                    if (!isValid(nc)) continue;
                    m1 += nc;
                    m2 += nc * nc;
                    cnt += 1.0;
                }
            }
            if (cnt > 0.0) {
                m1 /= cnt;
                m2 /= cnt;
                vec3 sigma = sqrt(max(m2 - m1 * m1, vec3(0.0)));
                float k = 4.0; // clamp range: wider = more temporal stability, narrower = less ghosting
                vec3 cmin = m1 - k * sigma;
                vec3 cmax = m1 + k * sigma;
                color_prev = clamp(color_prev, cmin, cmax);
            }
        }

        float alpha_color   = max(params.alpha, 1.0 / (histlen + 1.0));
        float alpha_moments = max(0.6, 1.0 / (histlen + 1.0));

        // A-SVGF gradient-based antilag
        if (params.useAdaptiveAlpha != 0u) {
            float antilag_alpha = computeAntilagAlpha(pixelCoord, size);
            alpha_color   = mix(alpha_color,   1.0, antilag_alpha);
            alpha_moments = mix(alpha_moments, 1.0, antilag_alpha);
        }

        outputColor   = mix(color_prev, color, alpha_color);
        outputMoments = mix(moments_prev, moments_curr, alpha_moments);
        outputLength  = clamp(1.0 / alpha_color, 0.0, 64.0);
    }
    else {
        outputColor   = color;
        outputMoments = moments_curr;
        outputLength  = 1.0;
    }

    outputColor = sanitize(outputColor, vec3(0.0));
    outputMoments.x = sanitize(outputMoments.x, 0.0);
    outputMoments.y = sanitize(outputMoments.y, 0.0);
    outputLength = sanitize(outputLength, 1.0);
    outputColor = clamp(outputColor, vec3(0.0), vec3(100.0));

    float outputVariance = max(0.0, outputMoments.y - outputMoments.x * outputMoments.x);
    outputVariance = sanitize(outputVariance, 0.0);

    imageStore(historyColorOut, pixelCoord, vec4(outputColor, 1.0));
    imageStore(historyMomentsOut, pixelCoord, vec4(outputMoments, 0.0, 0.0));
    imageStore(historyLengthOut, pixelCoord, vec4(outputLength, 0.0, 0.0, 0.0));
    imageStore(denoisedOutput, pixelCoord, vec4(outputColor, outputVariance));
}
